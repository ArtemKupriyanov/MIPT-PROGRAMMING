{"exec_count":21,"start":1522599257612,"input":"import numpy as np\nfrom numpy.linalg import det\nimport itertools\nfrom sympy.combinatorics import Permutation","state":"done","pos":0.5,"type":"cell","end":1522599257615,"id":"d4a04c","kernel":"anaconda3"}
{"exec_count":73,"start":1522600449536,"input":"class Variety():\n    def __init__(self, faces):\n        self.faces = faces\n        vertices = set(i for f in faces for i in f)\n        self.n = max(vertices)+1\n        assert set(range(self.n)) == vertices\n        self.edges = self._get_edges(return_unique=False)\n        self.unique_edges = self._get_edges(return_unique=True)\n        for f in faces:\n            assert len(f)==3\n\n    @property\n    def num_vertices(self):\n        return self.n\n\n    def check(self):\n        pass # Замените 'pass' на код функции, проверяющий self.faces\n\n    def Euler(self):\n        return self.num_vertices - len(self.unique_edges) + len(self.faces)\n\n    def d_0(self, func):\n        return lambda x, y: func(y) - func(x)\n\n    def d_1(self, func):\n        return lambda x, y, z: func(x, y) + func(y, z) + func(z, x)\n\n    def check_form(self, k, func):\n        assert k in [1, 2]\n        if k == 1:\n            if False in [func(edge[0], edge[1]) + func(edge[1], edge[0]) == 0 for edge in self.unique_edges]:\n                return False\n            return True\n        else:\n            for face in self.faces:\n                face = np.array(face)\n                if False in [func(*face) == Permutation(perm).signature() * func(*face[list(perm)]) for perm in itertools.permutations([0, 1, 2])]:\n                    return False\n            return True\n            \n\n    def wedge(self, k1, k2, f1, f2):\n        assert k1 in [0, 1, 2] and k2 in [0, 1, 2]\n        if k1 == k2 == 0:\n            return lambda x: f1(x) * f2(x)\n        if k1 == 0 and k2 == 1:\n            return lambda x, y: f2(x, y) * (f1(x) + f1(y)) / 2\n        if k1 == 1 and k2 == 0:\n            return lambda x, y: f1(x, y) * (f2(x) + f2(y)) / 2\n        if k1 == 0 and k2 == 2:\n            return lambda x, y, z: (f1(x) + f1(y) + f1(z)) / 3 * f2(x, y, z)\n        if k2 == 0 and k1 == 2:\n            return lambda x, y, z: (f2(x) + f2(y) + f2(z)) / 3 * f1(x, y, z)\n        if k1 == 1 and k2 == 1:\n            return lambda x, y, z: 1 / 6 * det(\n                                                np.array([\n                                                            [1, 1, 1],\n                                                            [f1(x, y), f1(y, z), f1(z, x)],\n                                                            [f2(x, y), f2(y, z), f2(z, x)]\n                                                        ])\n                                               )\n\n    def _get_edges(self, return_unique):\n        edges = []\n        for i, j, k in self.faces:\n            edges.append((i, j))\n            edges.append((j, k))\n            edges.append((k, i))\n        if return_unique:\n            return list(set([tuple(sorted(x)) for x in edges]))\n        else:\n            return edges","state":"done","pos":1,"cell_type":"code","type":"cell","end":1522600449756,"id":"9e6cb7","kernel":"anaconda3"}
{"output":{"0":{"data":{"text/plain":"[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]"},"exec_count":15}},"exec_count":15,"start":1522598811710,"input":"list(itertools.permutations([1, 2, 3]))","state":"done","pos":0.75,"type":"cell","end":1522598811723,"id":"e95238","kernel":"anaconda3"}
{"output":{"0":{"data":{"text/plain":"[0, 1, 2]"},"exec_count":27}},"exec_count":27,"start":1522599427264,"input":"p = Permutation((0, 1, 2))\np.array_form","state":"done","pos":0.875,"type":"cell","end":1522599427322,"id":"a5a777","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"Функция задания 1 не прошла проверку\nОшибок в задании 2 не найдено\nОшибок в задании 3 не найдено\nОшибок в задании 4 не найдено\nОшибок в задании 5 не найдено\nОшибок в задании 6.1 не найдено\nОшибок в задании 6.2 не найдено\nОшибок в задании 6.3 не найдено\nОшибок в задании 6.4 не найдено\n"}},"exec_count":74,"start":1522600450515,"input":"# примеры проверок (сначала запускаете ячейку с классом, потом с проверкой):\nsphere = Variety([(3,2,1), (2,3,0), (1,0,3),(0,1,2)])\ntorus = Variety([\n        (1,0,3),\n        (1,3,2),\n        (2,3,6),\n        (3,4,6),\n        (4,0,6),\n        (1,6,0),\n        (2,6,5),\n        (1,5,6),\n        (2,5,0),\n        (3,0,5),\n        (5,4,3),\n        (1,4,5),\n        (1,2,4),\n        (2,0,4),\n    ])\n\ndef test1():\n    assert sphere.check() == True\n    assert torus.check() == True\n    assert Variety([(1,2,3), (2,3,0), (3,0,1),(0,1,2)]).check() == False\n    assert Variety([(1,2,3), (2,3,1), (3,0,1),(0,1,2)]).check() == False\n    assert Variety([(1,2,0), (1,0,2)]).check() == False\n    assert Variety([(3,2,1), (2,3,0), (1,0,3),(0,1,2), (6,5,4), (5,6,0), (4,0,6),(0,4,5)]).check() == False\n\n\ndef test2():\n    assert sphere.Euler() == 2\n    assert torus.Euler() == 0\n\ndef test3():\n    assert sphere.d_0(lambda x : x)(1, 2) == 1\n    assert torus.d_0(lambda x : x**2)(4, 3) == -7\n\ndef test4():\n    assert sphere.check_form(2, lambda x,y,z : x+y+z if (x-y)*(y-z)*(z-x)>0 else -(x+y+z)) == True\n    assert torus.check_form(1,lambda v,w : 1) == False\n\ndef test5():\n    assert sphere.d_1(lambda x, y : x-y)(0, 1, 2) == 0\n    assert sphere.d_1(lambda x, y : x*y if x<y else -x*y)(1, 2, 3) == 5\n\ndef test61():\n    assert sphere.wedge(0,0, lambda x: x, lambda x: -x)(2) == -4\n\ndef test62():\n    assert sphere.wedge(0,1, lambda x: x, lambda x,y: y-x)(2,3) == 5/2\n\ndef test63():\n    assert sphere.wedge(0,2, lambda x: x, lambda x,y,z:  x+y+z if (x-y)*(y-z)*(z-x)>0 else -(x+y+z) )(0,1,2) == 3\n\ndef test64():\n    assert sphere.wedge(1,1, lambda x,y: x-y, lambda x,y: y-x)(1,2,3) == 0\n\ntests = [(1, test1),\n         (2, test2),\n         (3, test3),\n         (4, test4),\n         (5, test5),\n         (\"6.1\", test61),\n         (\"6.2\", test62),\n         (\"6.3\", test63),\n         (\"6.4\", test64),\n        ]\n\nfor i, t in tests:\n    try:\n        t()\n    except:\n        print('Функция задания {0} не прошла проверку'.format(i))\n    else:\n        print('Ошибок в задании {} не найдено'.format(i))\n\n","state":"done","pos":5,"type":"cell","end":1522600450759,"id":"c23362","kernel":"anaconda3"}
{"type":"cell","id":"31d379","pos":0,"input":"# Симплициальные многогранники и внешние формы\n\n## Порядок сдачи\nСрок сдачи задания -- **1 апреля**. 2 апреля работы будут собраны и уйдут на проверку. Сдача после дедлайна возможна в индивидуальном порядке за половинный балл.\n\nМожете объединяться в команды по 2-3 человека для совместного написания программ:\nдля этого нужно пригласить соответствующего студента в коллабораторы и указать в комментариях к коду, кто реализовал какое задание.\nМожете реализовывать задания по своему выбору. \nМаксимальная сумма, присуждаемая одному участнику -- **30** баллов.\nЕсли команда (из 1 или более человека) корректно реализовала все методы -- дополнительно присуждается по **10** баллов каждому.\n\nБудьте готовы к тому, что мы попросим некоторых из вас объяснить, что делает программа и как работает код. Использование чужого кода наказуемо аннулированием баллов у всех сторон подобного инцидента.\nПо всем вопросам пишите в чат в правом верхнем углу - мы увидим оповещение и ответим. Вопросы общего характера можно также задавать в telegram-чате.\n\n## Соглашения\n\nМы задаём ориентируемое симплициальное многообразие X без края с помощью класса Variety. Оно обладает X.n вершинами, пронумерованными числами от 0 до n-1.\nРёбра задаются парами вершин, (полу)рёбра -- парами вершин с учётом их порядка, а грани задаются тройками вершин с учётом ориентации, то есть направления обхода вершин.\nОсновным полем объекта X является X.faces -- массив ориентированных граней.\n- *0-форма* (функция на вершинах) является функцией, принимающей номер вершины и возвращающей значение.\n- *1-форма* (функция на рёбрах) является функцией, принимающей пару номеров вершин и возвращающей значение. Если пара вершин не задаёт ребро, то функция вольна возвращать произвольное значение. \n- *2-форма* (функция на гранях) является функцией, принимающей тройку номеров вершин и возвращающей значение. Если тройка вершин не задаёт грань, то функция вольна возвращать произвольное значение. \n\n## Задания\n\n1. *(5 баллов)* Напишите метод **check**(), проверяющий, задаёт ли faces (массив троек номеров вершин) симплициальное многообразие (ориентируемое, без края), и возвращающий соответствующее булево значение. Вам нужно проверить, что окрестность каждой вершины и окрестность каждого ребра гомеоморфны плоскости. *Указание:* удобнее проверять на полурёбрах.\n2. *(5 баллов)* Напишите метод **Euler**(), возвращающий эйлерову характеристику симплициального многообразия.\n3. *(5 баллов)* Напишите метод **d_0**(form), принимающий 0-форму и возвращающий её дифференциал -- 1-форму.\n4. *(5 баллов)* Напишите метод **check_form**(k, form), принимающий на вход k-форму и проверяющий её корректность, где k = 1 или 2.\n5. *(5 баллов)* Напишите метод **d_1**(form), принимающий 1-форму и возвращающий её дифференциал -- 2-форму.\n6. Напишите метод **wedge**(k1,k2, form1, form2), принимающий k1-форму и k2-форму и возвращающий их внешнее произведение, для (k1,k2)=\n  - *(5 баллов)* (0,0).\n  - *(5 баллов)* (0,1) и (1,0).\n  - *(10 баллов)* (0,2) и (2,0).\n  - *(15 баллов)* (1,1).\n","cell_type":"markdown"}
{"type":"file","last_load":1519994663656}
{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"kernel_usage":{"cpu":0,"memory":88023040},"kernel_state":"idle"}